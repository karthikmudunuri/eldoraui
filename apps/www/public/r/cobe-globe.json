{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "cobe-globe",
  "type": "registry:ui",
  "title": "cobe-globe",
  "description": "A cobe globe component.",
  "dependencies": [
    "react-spring",
    "cobe"
  ],
  "registryDependencies": [
    "button",
    "utils"
  ],
  "files": [
    {
      "path": "registry/eldoraui/cobe-globe.tsx",
      "content": "\"use client\"\n\nimport { useEffect, useRef, useState } from \"react\"\nimport createGlobe from \"cobe\"\nimport { useSpring } from \"react-spring\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\n\ntype CobeVariant =\n  | \"default\"\n  | \"draggable\"\n  | \"auto-draggable\"\n  | \"rotate-to-location\"\n  | \"scaled\"\n\ninterface Location {\n  name: string\n  lat?: number\n  long?: number\n  emoji?: string\n}\n\ninterface GeocodeResult {\n  lat: number\n  lng: number\n  display_name: string\n}\n\ninterface CobeProps {\n  variant?: CobeVariant\n  className?: string\n  style?: React.CSSProperties\n  locations?: Location[]\n}\n\ntype CobeState = Record<string, any>\n\nexport function Cobe({\n  variant = \"default\",\n  className,\n  style,\n  locations = [\n    { name: \"San Francisco\", emoji: \"üìç\" },\n    { name: \"Berlin\", emoji: \"üìç\" },\n    { name: \"Tokyo\", emoji: \"üìç\" },\n    { name: \"Buenos Aires\", emoji: \"üìç\" },\n  ],\n}: CobeProps) {\n  const canvasRef = useRef<HTMLCanvasElement>(null)\n  const pointerInteracting = useRef<number | null>(null)\n  const pointerInteractionMovement = useRef<number>(0)\n  const focusRef = useRef<[number, number]>([0, 0])\n  const [customLocations, setCustomLocations] = useState<Location[]>([])\n  const [isInitializing, setIsInitializing] = useState(true)\n\n  const [{ r }, api] = useSpring<{ r: number }>(() => ({\n    r: 0,\n    config: {\n      mass: 1,\n      tension: 280,\n      friction: 40,\n      precision: 0.001,\n    },\n  }))\n\n  const locationToAngles = (lat: number, long: number): [number, number] => {\n    return [\n      Math.PI - ((long * Math.PI) / 180 - Math.PI / 2),\n      (lat * Math.PI) / 180,\n    ] as [number, number]\n  }\n\n  const geocodeLocation = async (\n    query: string\n  ): Promise<GeocodeResult | null> => {\n    try {\n      const response = await fetch(\n        `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=1`\n      )\n      const data = await response.json()\n\n      if (data && data.length > 0) {\n        return {\n          lat: parseFloat(data[0].lat),\n          lng: parseFloat(data[0].lon),\n          display_name: data[0].display_name,\n        }\n      }\n      return null\n    } catch (error) {\n      console.error(\"Geocoding error:\", error)\n      return null\n    }\n  }\n\n  const geocodeLocationList = async (locationList: Location[]) => {\n    const geocodedLocations: Location[] = []\n\n    for (const location of locationList) {\n      if (location.lat && location.long) {\n        // Already has coordinates\n        geocodedLocations.push(location)\n      } else {\n        // Need to geocode\n        const result = await geocodeLocation(location.name)\n        if (result) {\n          geocodedLocations.push({\n            ...location,\n            lat: result.lat,\n            long: result.lng,\n          })\n        }\n      }\n    }\n\n    return geocodedLocations\n  }\n\n  // Initialize locations on component mount\n  useEffect(() => {\n    const initializeLocations = async () => {\n      if (variant === \"rotate-to-location\" && locations.length > 0) {\n        setIsInitializing(true)\n        const geocoded = await geocodeLocationList(locations)\n        setCustomLocations(geocoded)\n        setIsInitializing(false)\n      }\n    }\n\n    initializeLocations()\n  }, [variant, locations])\n\n  useEffect(() => {\n    let phi = 0\n    let width = 0\n    let currentPhi = 0\n    let currentTheta = 0\n    const doublePi = Math.PI * 2\n\n    const onResize = () => {\n      if (canvasRef.current) {\n        width = canvasRef.current.offsetWidth\n      }\n    }\n\n    window.addEventListener(\"resize\", onResize)\n    onResize()\n\n    if (!canvasRef.current) return\n\n    const globe = createGlobe(canvasRef.current, {\n      devicePixelRatio: 2,\n      width: width * 2,\n      height: variant === \"scaled\" ? width * 2 * 0.4 : width * 2,\n      phi: 0,\n      theta: 0.3,\n      dark: 1,\n      diffuse: 3,\n      mapSamples: 16000,\n      mapBrightness: 1.2,\n      baseColor: [1, 1, 1],\n      markerColor:\n        variant === \"rotate-to-location\"\n          ? [34 / 255, 211 / 255, 238 / 255]\n          : [8 / 255, 145 / 255, 178 / 255],\n      glowColor: [1.2, 1.2, 1.2],\n      markers:\n        variant === \"rotate-to-location\"\n          ? customLocations\n              .filter((loc) => loc.lat && loc.long)\n              .map((loc) => ({\n                location: [loc.lat!, loc.long!],\n                size: 0.1,\n              }))\n          : [],\n      scale: variant === \"scaled\" ? 2.5 : undefined,\n      offset: variant === \"scaled\" ? [0, width * 2 * 0.4 * 0.6] : undefined,\n      onRender: (state: CobeState) => {\n        switch (variant) {\n          case \"default\":\n            state.phi = phi\n            phi += 0.005\n            break\n          case \"draggable\":\n            state.phi = r.get()\n            break\n          case \"auto-draggable\":\n            if (!pointerInteracting.current) {\n              phi += 0.005\n            }\n            state.phi = phi + r.get()\n            break\n          case \"rotate-to-location\":\n            state.phi = currentPhi\n            state.theta = currentTheta\n            const [focusPhi, focusTheta] = focusRef.current\n            const distPositive = (focusPhi - currentPhi + doublePi) % doublePi\n            const distNegative = (currentPhi - focusPhi + doublePi) % doublePi\n            if (distPositive < distNegative) {\n              currentPhi += distPositive * 0.08\n            } else {\n              currentPhi -= distNegative * 0.08\n            }\n            currentTheta = currentTheta * 0.92 + focusTheta * 0.08\n            break\n          case \"scaled\":\n            // No rotation for scaled variant\n            break\n        }\n\n        state.width = width * 2\n        state.height = variant === \"scaled\" ? width * 2 * 0.4 : width * 2\n      },\n    })\n\n    if (canvasRef.current) {\n      setTimeout(() => {\n        if (canvasRef.current) {\n          canvasRef.current.style.opacity = \"1\"\n        }\n      })\n    }\n\n    return () => {\n      globe.destroy()\n      window.removeEventListener(\"resize\", onResize)\n    }\n  }, [variant, r, customLocations])\n\n  const handlePointerDown = (e: React.PointerEvent) => {\n    if (variant === \"draggable\" || variant === \"auto-draggable\") {\n      pointerInteracting.current =\n        e.clientX - pointerInteractionMovement.current\n      if (canvasRef.current) canvasRef.current.style.cursor = \"grabbing\"\n    }\n  }\n\n  const handlePointerUp = () => {\n    if (variant === \"draggable\" || variant === \"auto-draggable\") {\n      pointerInteracting.current = null\n      if (canvasRef.current) canvasRef.current.style.cursor = \"grab\"\n    }\n  }\n\n  const handlePointerOut = () => {\n    if (variant === \"draggable\" || variant === \"auto-draggable\") {\n      pointerInteracting.current = null\n      if (canvasRef.current) canvasRef.current.style.cursor = \"grab\"\n    }\n  }\n\n  const handleMouseMove = (e: React.MouseEvent) => {\n    if (\n      (variant === \"draggable\" || variant === \"auto-draggable\") &&\n      pointerInteracting.current !== null\n    ) {\n      const delta = e.clientX - pointerInteracting.current\n      pointerInteractionMovement.current = delta\n      api.start({\n        r: delta / 200,\n      })\n    }\n  }\n\n  const handleTouchMove = (e: React.TouchEvent) => {\n    if (\n      (variant === \"draggable\" || variant === \"auto-draggable\") &&\n      pointerInteracting.current !== null &&\n      e.touches[0]\n    ) {\n      const delta = e.touches[0].clientX - pointerInteracting.current\n      pointerInteractionMovement.current = delta\n      api.start({\n        r: delta / 100,\n      })\n    }\n  }\n\n  const handleLocationClick = (lat: number, long: number) => {\n    if (variant === \"rotate-to-location\") {\n      focusRef.current = locationToAngles(lat, long)\n    }\n  }\n\n  const containerStyle = {\n    width: \"100%\",\n    maxWidth: 600,\n    aspectRatio: variant === \"scaled\" ? 1 / 0.4 : 1,\n    margin: \"auto\",\n    position: \"relative\" as const,\n    ...style,\n  }\n\n  const canvasStyle = {\n    width: \"100%\",\n    height: \"100%\",\n    contain: \"layout paint size\" as const,\n    opacity: 0,\n    transition: \"opacity 1s ease\",\n    cursor:\n      variant === \"draggable\" || variant === \"auto-draggable\"\n        ? \"grab\"\n        : undefined,\n  }\n\n  return (\n    <div className={cn(\"\", className)} style={containerStyle}>\n      <canvas\n        ref={canvasRef}\n        onPointerDown={handlePointerDown}\n        onPointerUp={handlePointerUp}\n        onPointerOut={handlePointerOut}\n        onMouseMove={handleMouseMove}\n        onTouchMove={handleTouchMove}\n        style={canvasStyle}\n      />\n      {variant === \"rotate-to-location\" && (\n        <>\n          <div\n            className=\"control-buttons flex flex-col items-center justify-center md:flex-row\"\n            style={{ gap: \".5rem\" }}\n          >\n            {isInitializing ? \"Loading locations...\" : \"\"}\n            {customLocations\n              .filter((loc) => loc.lat && loc.long)\n              .map((location, index) => (\n                <Button\n                  key={index}\n                  onClick={() =>\n                    handleLocationClick(location.lat!, location.long!)\n                  }\n                  className=\"bg-background/80 text-foreground hover:bg-background/90 border-border transition-all duration-200 hover:scale-105\"\n                >\n                  {location.emoji || \"üìç\"} {location.name}\n                </Button>\n              ))}\n          </div>\n        </>\n      )}\n    </div>\n  )\n}\n",
      "type": "registry:ui"
    }
  ]
}