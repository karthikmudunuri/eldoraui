{
  "name": "scramblehover",
  "type": "registry:ui",
  "dependencies": [
    "framer-motion"
  ],
  "files": [
    {
      "path": "eldoraui/scramblehover.tsx",
      "content": "import { useState, useEffect } from \"react\";\nimport { motion } from \"framer-motion\";\nimport { cn } from \"@/lib/utils\";\n\ninterface ScrambleHoverProps {\n  text: string;\n  scrambleSpeed?: number;\n  maxIterations?: number;\n  sequential?: boolean;\n  revealDirection?: \"start\" | \"end\" | \"center\";\n  useOriginalCharsOnly?: boolean;\n  characters?: string;\n  className?: string;\n  scrambledClassName?: string;\n}\n\nconst ScrambleHover: React.FC<ScrambleHoverProps> = ({\n  text,\n  scrambleSpeed = 50,\n  maxIterations = 10,\n  useOriginalCharsOnly = false,\n  characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!@#$%^&*()_+\",\n  className,\n  scrambledClassName,\n  sequential = false,\n  revealDirection = \"start\",\n  ...props\n}) => {\n  const [displayText, setDisplayText] = useState(text);\n  const [isHovering, setIsHovering] = useState(false);\n  const [isScrambling, setIsScrambling] = useState(false);\n  const [revealedIndices, setRevealedIndices] = useState(new Set<number>());\n\n  useEffect(() => {\n    let interval: NodeJS.Timeout;\n    let currentIteration = 0;\n\n    const getNextIndex = () => {\n      const textLength = text.length;\n      switch (revealDirection) {\n        case \"start\":\n          return revealedIndices.size;\n        case \"end\":\n          return textLength - 1 - revealedIndices.size;\n        case \"center\":\n          const middle = Math.floor(textLength / 2);\n          const offset = Math.floor(revealedIndices.size / 2);\n          const nextIndex =\n            revealedIndices.size % 2 === 0\n              ? middle + offset\n              : middle - offset - 1;\n\n          if (\n            nextIndex >= 0 &&\n            nextIndex < textLength &&\n            !revealedIndices.has(nextIndex)\n          ) {\n            return nextIndex;\n          }\n\n          for (let i = 0; i < textLength; i++) {\n            if (!revealedIndices.has(i)) return i;\n          }\n          return 0;\n        default:\n          return revealedIndices.size;\n      }\n    };\n\n    const shuffleText = (text: string) => {\n      if (useOriginalCharsOnly) {\n        const positions = text.split(\"\").map((char, i) => ({\n          char,\n          isSpace: char === \" \",\n          index: i,\n          isRevealed: revealedIndices.has(i),\n        }));\n\n        const nonSpaceChars = positions\n          .filter((p) => !p.isSpace && !p.isRevealed)\n          .map((p) => p.char);\n\n        // Shuffle remaining non-revealed, non-space characters\n        for (let i = nonSpaceChars.length - 1; i > 0; i--) {\n          const j = Math.floor(Math.random() * (i + 1));\n          [nonSpaceChars[i], nonSpaceChars[j]] = [\n            nonSpaceChars[j],\n            nonSpaceChars[i],\n          ];\n        }\n\n        let charIndex = 0;\n        return positions\n          .map((p) => {\n            if (p.isSpace) return \" \";\n            if (p.isRevealed) return text[p.index];\n            return nonSpaceChars[charIndex++];\n          })\n          .join(\"\");\n      } else {\n        return text\n          .split(\"\")\n          .map((char, i) => {\n            if (char === \" \") return \" \";\n            if (revealedIndices.has(i)) return text[i];\n            return availableChars[\n              Math.floor(Math.random() * availableChars.length)\n            ];\n          })\n          .join(\"\");\n      }\n    };\n\n    const availableChars = useOriginalCharsOnly\n      ? Array.from(new Set(text.split(\"\"))).filter((char) => char !== \" \")\n      : characters.split(\"\");\n\n    if (isHovering) {\n      setIsScrambling(true);\n      interval = setInterval(() => {\n        if (sequential) {\n          if (revealedIndices.size < text.length) {\n            const nextIndex = getNextIndex();\n            revealedIndices.add(nextIndex);\n            setDisplayText(shuffleText(text));\n          } else {\n            clearInterval(interval);\n            setIsScrambling(false);\n          }\n        } else {\n          setDisplayText(shuffleText(text));\n          currentIteration++;\n          if (currentIteration >= maxIterations) {\n            clearInterval(interval);\n            setIsScrambling(false);\n            setDisplayText(text);\n          }\n        }\n      }, scrambleSpeed);\n    } else {\n      setDisplayText(text);\n      revealedIndices.clear();\n    }\n\n    return () => {\n      if (interval) clearInterval(interval);\n    };\n  }, [isHovering, text, characters, scrambleSpeed, useOriginalCharsOnly, sequential, revealDirection, maxIterations, revealedIndices]);\n\n  return (\n    <motion.span\n      onHoverStart={() => setIsHovering(true)}\n      onHoverEnd={() => setIsHovering(false)}\n      className={cn(\"inline-block whitespace-pre-wrap\", className)}\n      {...props}\n    >\n      {displayText.split(\"\").map((char, index) => (\n        <span\n          key={index}\n          className={cn(\n            revealedIndices.has(index) || !isScrambling || !isHovering\n              ? className\n              : scrambledClassName\n          )}\n        >\n          {char}\n        </span>\n      ))}\n    </motion.span>\n  );\n};\n\nexport default ScrambleHover;\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}